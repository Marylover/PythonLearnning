高阶函数2
---
## 1. 过滤函数（`filter(fun,list)`）
1. 它接受两个参数，`fun()`：一个函数，`list[]`:一个列表。它会把`list`中的元素按照`fun()`的条件过滤(根据返回值是`True`或`False`决定保留还是丢弃该元素)，例如：
  ```py
  def is_odd(n): #判断一个数是否为奇数
    return n%2 == 1
  list(filter(is_odd,[1,2,3,4,5,6])) #结果：[1,3,5]
  ```
2. 例二：用艾氏篩法求素数，即：
   > 1.列出从2开始的所有自然数，构造一个序列   
   > 2.取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉  
   > 3.取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉  
   > 4.取新序列的第一个数5，然后用5把序列的5的倍数筛掉  
   > 5.不断筛下去，就可以得到所有的素数

    ```py
    def _odd_iter(): #定义一个可以生成从3开始的奇数序列，它是一个无限序列，因为这是一个生成器
        n = 1
        while True:
            n = n + 2
            yield n

    def _not_divisible(n): #定义一个筛选函数，当x为n的倍数时为False,否则为True
        return lambda x：x % n > 0
    def primes():
        yield 2 #2是第一个素数
        it = _odd_iter() # 初始化序列 
        while True:
            n = next(it) #返回序列的第一个数
            yield n 
            it = filter(_no_divisible(n),it) # 构造不是原序列头元素倍数的新序列
    for n in primes(): #打印1000内的素数
        if n < 1000:
            print(n)
        else:
            break
    ``` 

## 2.排序算法(`sorted(list[],key = fun)`)
1. 如果没有`key`参数，则默认按照对数字的从小到大的排序，对字符串按照首字母的`ASSCII`的大小排序。
2. 若有`key`参数，则相当于把list[]中元素做一个映射，再对映射元素排序  
> 例子：假设我们用一组tuple表示学生名字和成绩：  
L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]  
对上述列表分别按成绩和名字排序  

```py
def by_score(t):
    return t[1] #映射为元组的第二个元素
def by_name(t):
    return t[0] #映射为元组的第二个元素
L1 = sorted(L,key = by_score)
L2 = sorted(L,key = by_name)
```

## 3.返回函数
1. 即高阶函数除了可以接受函数作参数，还可把函数作为结果值返回  
   例如：
   ```py
   def lazy_sum(*args):
       def sum(): #定义一个作为lazy_sum()返回值的函数
           ax = 0
           for n in args:
               ax = ax + n
               return ax
        return sum 
   ```
   当我们调用`lazy_sum()`时，返回的并不是求和结果，而是`sum()`函数。  
   **在函数`lazy_sum`中又定义了函数`sum`，并且，内部函数`sum`可以引用外部函数`lazy_sum`的参数和局部变量，当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。**  
   **两次调用`lazy_sum()`函数时，返回的`sum()`函数并不相同，即使两次的`lazy_sum()`参数相同**：  
   `f1 = lazy_sum(1, 3, 5, 7, 9)`  
   `f2 = lazy_sum(1, 3, 5, 7, 9)`  
   `f1==f2`  
   **`False`**   

   ## 4.匿名函数（`lambda()`），已讨论

   ## 5.装饰器（`Decorator`）  
   1. 本质上，它是一个返回函数的高阶函数，例如，一个可以打印日志的decocrator:
    ```py
    def log(func):
        def wrapper(*args, **kw):
            print('call %s():' % func.__name__)
             return func(*args, **kw)
    return wrapper
   ```
   如果希望这个函数作用于一个一般函数，需要借助`Python`的`@`语法，把`decorator`置于函数的定义出：
    ```py
    @log
    def now():
        print('2018-9-30')
    ```
    则，调用`now()`函数时，不仅会运行`now()`函数本身，还会在运行`now()`函数前打印一行日志：  
    `>>> now()`  
    `call now():`  
    `2018-9-30`  

   2. 若`decorator`本身需要传入参数，则需定义三层函数：  
   ```py
    def log(text):
        def decorator(func):
            def wrapper(*args, **kw):
                print('%s %s():' % (text, func.__name__))
                return func(*args, **kw)
            return wrapper
    return decorator
   ```
   执行时：先把参数`text`传入，然后执行`decorator`函数，传入参数`func`,然后执行`wapper`函数，用`text`和`func`函数执行日志功能，最后返回要执行的普通函数`func`.  
   
   ---
   ## **`@`语法说明：**  
   



   


   




